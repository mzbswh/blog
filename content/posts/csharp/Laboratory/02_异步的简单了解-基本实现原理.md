---
title: 异步的简单了解-基本实现原理
subtitle:
date: 2024-11-17T19:34:08+08:00
slug: 0b5f289
draft: true
author:
  name: mzbswh
  link:
  email:
  avatar:
description:
keywords:
license:
comment: false
weight: 0
tags:
  - c#
categories:
  - c#
collections:
  - c#研究室
hiddenFromHomePage: false
hiddenFromSearch: false
hiddenFromRelated: false
hiddenFromFeed: false
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: true
math: false
lightgallery: false
password:
message:
repost:
  enable: true
  url:

# See details front matter: https://fixit.lruihao.cn/documentation/content-management/introduction/#front-matter
---

> [!TIP] 前言
> C#中的异步编程是一种处理长时间运行任务的方式，可以避免阻塞主线程，从而提升应用程序的响应性和性能。异步也可以使回调的写法更加简单明了和线性化, 可以避免嵌套多层的"回调地狱"。本文主要介绍异步背后的一些基本实现原理。

### 异步基本写法

```csharp
public class AsyncTest
{
    public async Task FooAsync()
    {
        Console.WriteLine("step1");
        await Task.Delay(1000);
        Console.WriteLine("step2");
        await Task.Delay(1000);
        Console.WriteLine("step3");
    }

    public void Foo()
    {
        _ = FooAsync();
        Console.WriteLine("执行完成");
    }
}
```  

上面的代码展示了一个非常简单的一个异步写法, 先打印`Step1`, 等1秒后打印`Step2`, 再等1秒打印`Step3`。

> [!QUESTION] 在执行Foo时，可以观察到控制台的打印依次为 `Step1`-`执行完成`-`Step2`-`Step3`, 为什么会是这样的执行顺序呢？

### 异步的实现原理

`AsyncTest`编译为IL时对应的等效c#代码：

```csharp
public class AsyncTest
{
    private sealed class FooAsyncStateMachine : IAsyncStateMachine
    {
        public int state;
        public AsyncTaskMethodBuilder taskBuilder;
        public AsyncTest asyncTest;
        private int _a;
        private TaskAwaiter _awaiter;

        public FooAsyncStateMachine()
        {
            state = -1;
            taskBuilder = AsyncTaskMethodBuilder.Create();
        }

        void IAsyncStateMachine.MoveNext()
        {
            int num = state;
            try
            {
                TaskAwaiter awaiter;
                if (num != 0)
                {
                    if (num == 1)
                    {
                        // step6(第三次MoveNext): 第二个等待完成
                        awaiter = _awaiter;
                        _awaiter = default;
                        awaiter.GetResult();
                        // step7: 执行 a+=2; 全部执行完成
                        Console.WriteLine("step3")
                        return;
                    }
                    // step1(第一次MoveNext): Console.WriteLine("step1"); await Task.Delay(1000);
                    Console.WriteLine("step1");
                    awaiter = Task.Delay(1000).GetAwaiter();
                    if (!awaiter.IsCompleted)
                    {
                        // step2: 第一个等待未完成, 状态=0 return
                        num = state = 0;
                        _awaiter = awaiter;
                        var stateMachine = this;
                        taskBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);
                        return;
                    }
                }
                else
                {
                    // step3(第二次MoveNext): 第一个等待完成
                    awaiter = _awaiter;
                    _awaiter = default;
                    num = state = -1;
                }
                awaiter.GetResult();
                // step4: 执行 Console.WriteLine("step2"); await Task.Delay(1000);
                Console.WriteLine("step2");
                awaiter = Task.Delay(1000).GetAwaiter();
                if (!awaiter.IsCompleted)   // 会立即判断任务是否完成
                {
                    // step5: 第二个等待未完成, 状态=1 return
                    num = state = 1;
                    _awaiter = awaiter;
                    var stateMachine = this;
                    taskBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);
                    return;
                }
            }
            catch (Exception exception)
            {
                state = -2;
                taskBuilder.SetException(exception);
                return;
            }
            state = -2;
            taskBuilder.SetResult();
        }

        [DebuggerHidden]
        void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)
        {
            taskBuilder.SetStateMachine(stateMachine);
        }
    }

    [AsyncStateMachine(typeof(FooAsyncStateMachine))]
    public Task FooAsync()
    {
        var stateMachine = new FooAsyncStateMachine();
        stateMachine.asyncTest = this;
        stateMachine.taskBuilder.Start(ref stateMachine);
        return stateMachine.taskBuilder.Task;
    }

    public AsyncTest()
    {
    }
}
```

**可以看到, c#背后将异步代码编译生成为了一个状态机, 异步的执行实际就是驱动状态机的执行。**

==上述代码的注释即为状态机的运行步骤顺序。==[info]

`Foo`执行实际执行流程:
- 执行`FooAsync`
- 创建`FooAsyncStateMachine`状态机器类
- `AsyncTaskMethodBuilder`启动状态机
- 状态机执行到第一个`await Task.Delay(1000)`时返回
- `FooAsync`方法执行完成并返回了一个`Task`
- `Foo`方法就继续往下执行`Console.WriteLine("执行完成");`

> [!QUESTION] 怎么让`Foo`全部执行完后才执行`Console.WriteLine("执行完成");`呢？

将`Foo`代码改为如下形式:

```
public async void Foo()
{
    await FooAsync();
    Console.WriteLine("执行完成");
}
```

上述代码将`Foo`改为了异步形式, 并对`FooAsync`添加对等待。同`FooAsync`, 此时`Foo`方法也被编译为了一个状态机, 只有当`FooAsync`全部执行完后, 即`FooAsync`状态机执行到`SetResult()`时, `FooAsync`被标记为执行完成, 并驱动`Foo`状态机继续往下执行。

### 状态机的驱动